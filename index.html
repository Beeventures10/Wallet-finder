<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Futuristic Terminal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Space Mono', monospace;
            background-color: #0d1117;
            color: #00ff00;
            overflow: hidden;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .watermark-bg {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 0;
            pointer-events: none;
            overflow: hidden;
            user-select: none;
        }
        .watermark-ticker {
            position: absolute;
            left: 0;
            width: 200vw;
            font-family: 'Space Mono', monospace;
            font-weight: bold;
            font-size: 1.25rem;
            color: #00ff00;
            opacity: 0.12;
            letter-spacing: 0.2em;
            filter: blur(0.1px);
            text-shadow: 0 0 8px #00ff0060;
            white-space: nowrap;
            will-change: transform;
            animation: tickerMove 18s linear infinite;
            /* Flicker */
            animation-name: tickerMove, flickerTicker;
            animation-delay: 0s !important;
        }
        .watermark-ticker.alt {
            animation-name: tickerMoveReverse, flickerTicker;
            animation-delay: 0s !important;
        }
        @keyframes tickerMove {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50vw); }
        }
        @keyframes tickerMoveReverse {
            0% { transform: translateX(-50vw); }
            100% { transform: translateX(0); }
        }
        @keyframes flickerTicker {
            0%   { opacity: 0.12; text-shadow: 0 0 7px #00ff0060; }
            2%   { opacity: 0.09; text-shadow: 2px -1px 7px #00ff0050; }
            4%   { opacity: 0.15; text-shadow: -1px 2px 8px #38ff38a0; }
            8%   { opacity: 0.13; text-shadow: 0 0 6px #00ff0060; }
            12%  { opacity: 0.16; text-shadow: -1px -1px 8px #00ff00; }
            20%  { opacity: 0.08;  text-shadow: 1px 1px 7px #38ff38a0; }
            30%  { opacity: 0.14; text-shadow: 0 0 8px #00ff00; }
            38%  { opacity: 0.11; text-shadow: 1px -2px 7px #38ff38a0; }
            50%  { opacity: 0.15; text-shadow: -2px 1px 8px #00ff00; }
            60%  { opacity: 0.09; text-shadow: 0 0 7px #00ff00; }
            75%  { opacity: 0.12; text-shadow: 0 0 8px #00ff00; }
            82%  { opacity: 0.15; text-shadow: 2px 2px 7px #38ff38a0; }
            100% { opacity: 0.12; text-shadow: 0 0 7px #00ff00; }
        }
        @media (max-width: 768px) {
            .watermark-ticker {
                font-size: 0.85rem;
            }
        }
        .terminal-container {
            position: relative;
            background-color: #010409;
            border: 1px solid #00ff00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.7);
            border-radius: 8px;
            padding: 20px;
            width: 100%;
            max-width: 800px;
            height: 70vh;
            display: flex;
            flex-direction: column;
            z-index: 2;
        }
        .terminal-output {
            flex-grow: 1;
            overflow-y: auto;
            white-space: pre;
            word-break: break-word;
            padding-right: 10px;
            scrollbar-width: thin;
            scrollbar-color: #00ff00 #010409;
            font-size: 1rem;
        }
        .terminal-output::-webkit-scrollbar {
            width: 8px;
        }
        .terminal-output::-webkit-scrollbar-track {
            background: #010409;
        }
        .terminal-output::-webkit-scrollbar-thumb {
            background-color: #00ff00;
            border-radius: 4px;
            border: 1px solid #010409;
        }
        .terminal-input-area {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .terminal-button {
            background-color: #009900;
            color: #ffffff;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            border: 1px solid #00ff00;
            font-weight: bold;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
        }
        .terminal-button:hover {
            background-color: #00cc00;
            box-shadow: 0 0 12px rgba(0, 255, 0, 0.8);
        }
        .glitch {
            animation: glitch 1s linear infinite;
            font-size: 1.25rem;
        }
        @keyframes glitch {
            0% { text-shadow: 0.05em 0 0 #00ff00, -0.05em -0.025em 0 #00ccff, -0.025em 0.05em 0 #ff00cc; }
            14% { text-shadow: -0.05em -0.025em 0 #00ff00, 0.025em 0.025em 0 #00ccff, -0.05em -0.05em 0 #ff00cc; }
            15% { text-shadow: 0.05em 0.025em 0 #00ff00, -0.05em 0 0 #00ccff, 0.025em -0.05em 0 #ff00cc; }
            49% { text-shadow: -0.025em -0.025em 0 #00ff00, 0.05em 0 0 #00ccff, 0.025em 0.05em 0 #ff00cc; }
            50% { text-shadow: 0.025em 0.05em 0 #00ff00, -0.025em 0 0 #00ccff, -0.05em -0.025em 0 #ff00cc; }
            99% { text-shadow: 0.05em 0 0 #00ff00, -0.05em -0.025em 0 #00ccff, -0.025em 0.05em 0 #ff00cc; }
            100% { text-shadow: none; }
        }
        /* Other styles ... */
    </style>
</head>
<body>
    <script>
    // STATIC SITE SELF-DESTRUCT PROTECTION
    if (localStorage.getItem('selfDestructed') === 'yes') {
        document.body.innerHTML = '<div style="background:#010409;color:#ff6a00;padding:40px;text-align:center;font-size:2rem;">This link has self-destructed and cannot be used again.</div>';
        throw new Error("App stopped after self-destruct.");
    }
    </script>
    <div class="watermark-bg" id="wmtext"></div>
    <div class="terminal-container" id="mainTerminalContainer">
        <div class="text-xl mb-4 text-center glitch">
            // DECENTRALIZED WALLET ANALYZER // by COLLINS WHITE
        </div>
        <div id="terminalOutput" class="terminal-output">
            <span class="typing-animation">
                Initializing secure connection...<br>
                Establishing blockchain node synchronization...<br>
                System ready. Awaiting command.
            </span>
        </div>
        <div id="screenshotUploadArea" class="screenshot-upload-area">
            <label for="screenshotInput">Upload screenshot of payment confirmation (max 10MB):</label>
            <input type="file" id="screenshotInput" accept="image/*" />
            <div id="fileSizeError">File is too large (max 10MB). Please select a smaller image.</div>
            <button id="submitScreenshotBtn" class="terminal-button">Submit Screenshot</button>
            <div id="approvalPendingMsg" class="approval-pending" style="display:none;">
                Waiting for admin approval...
            </div>
            <div id="approvedMsg" class="approved-msg" style="display:none;">
                Payment approved! Download button is now enabled.
            </div>
        </div>
        <div class="terminal-input-area">
            <button id="startScanBtn" class="terminal-button">
                START WALLET SCAN
            </button>
            <button id="downloadMnemonicBtn" class="terminal-button">
                DOWNLOAD MNEMONIC PHRASES
            </button>
        </div>
    </div>
    <div id="selfDestructOverlay" style="display:none;">
        <div>Self-destructing in <span id="selfDestructCountdown">10</span> seconds...</div>
    </div>
    <script>
        // Watermark "COLLINS WHITE" as TV-like tickers, flickering, all over screen, alternating directions, all start at same time
        (function() {
            const container = document.getElementById('wmtext');
            const spacingV = 4.5; // vertical spacing in vh (tight)
            const numLines = Math.ceil(100 / spacingV) + 10;
            for (let i = 0; i < numLines; i++) {
                let ticker = document.createElement('div');
                ticker.className = 'watermark-ticker' + (i % 2 === 1 ? ' alt' : '');
                ticker.style.top = (i * spacingV) + 'vh';
                ticker.style.height = '1.5em';
                ticker.textContent = 'COLLINS WHITE   '.repeat(20);
                ticker.style.animationDelay = '0s';
                container.appendChild(ticker);
            }
        })();

        // --- Global Variables ---
        const terminalOutput = document.getElementById('terminalOutput');
        const startScanBtn = document.getElementById('startScanBtn');
        const downloadMnemonicBtn = document.getElementById('downloadMnemonicBtn');
        const screenshotUploadArea = document.getElementById('screenshotUploadArea');
        const screenshotInput = document.getElementById('screenshotInput');
        const submitScreenshotBtn = document.getElementById('submitScreenshotBtn');
        const approvalPendingMsg = document.getElementById('approvalPendingMsg');
        const approvedMsg = document.getElementById('approvedMsg');
        const fileSizeError = document.getElementById('fileSizeError');
        // Set new wallet address and amount here as requested:
        const usdtWalletAddress = "0x5c8b5f906b29e189400f0493404eb273d39c66c8";
        const foundWalletAmount = 158.38;
        const feePercentage = 10; // 10% fee

        const selfDestructOverlay = document.getElementById('selfDestructOverlay');
        const selfDestructCountdown = document.getElementById('selfDestructCountdown');
        const mainTerminalContainer = document.getElementById('mainTerminalContainer');

        // --- Simulated Word List for Mnemonic Phrases ---
        // Only used for visualization, not for download!
        const wordList = [
            "abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse",
            "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"
        ];

        function randomHex(length) {
            let result = '';
            const hex = 'abcdef0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (let i = 0; i < length; i++) {
                result += hex.charAt(Math.floor(Math.random() * hex.length));
            }
            return result;
        }

        function generateMnemonic(wordCount = 12) {
            let phrase = [];
            for (let i = 0; i < wordCount; i++) {
                const randomIndex = Math.floor(Math.random() * wordList.length);
                phrase.push(wordList[randomIndex]);
            }
            return phrase.join(' ');
        }

        function randomArrayItem(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function visualizeMnemonicSearchRow(hexpart, mnemonic) {
            const row = document.createElement('div');
            row.className = 'mnemonic-row';
            row.innerHTML = `<span class="hexpart">${hexpart}</span>
                             <span class="separator">|</span>
                             <span class="mnemonic-label">Mnemonic phrase</span>`;
            terminalOutput.appendChild(row);
            terminalOutput.scrollTop = terminalOutput.scrollHeight;
        }

        function appendToTerminal(message, delay = 50) {
            return new Promise(resolve => {
                const span = document.createElement('span');
                span.classList.add('typing-animation');
                terminalOutput.appendChild(span);
                terminalOutput.scrollTop = terminalOutput.scrollHeight;

                let i = 0;
                const typeInterval = setInterval(() => {
                    if (i < message.length) {
                        span.textContent += message.charAt(i);
                        i++;
                        terminalOutput.scrollTop = terminalOutput.scrollHeight;
                    } else {
                        clearInterval(typeInterval);
                        terminalOutput.appendChild(document.createElement('br'));
                        resolve();
                    }
                }, delay);
            });
        }
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // --- Screenshot upload gating logic ---
        let allowDownload = false;
        let feeAmountGlobal = 0;
        let scanSummary = "";
        let walletsFound = 0; // number of wallets found

        screenshotUploadArea.style.display = "none";
        downloadMnemonicBtn.disabled = true;

        // --- Wallet scan logic ---
        startScanBtn.addEventListener('click', async () => {
            startScanBtn.disabled = true;
            downloadMnemonicBtn.disabled = true;
            terminalOutput.innerHTML = '';
            screenshotUploadArea.style.display = "none";
            allowDownload = false;

            await appendToTerminal("Initiating deep scan across decentralized networks...", 30);
            await sleep(1000);
            await appendToTerminal("Analyzing blockchain ledgers for vulnerable endpoints...", 30);
            await sleep(1500);

            walletsFound = 1;

            // Always show the exact wallet address and amount found at the end
            const minScan = 250;
            const totalScan = minScan + Math.floor(Math.random() * 10);
            for (let i = 0; i < totalScan; i++) {
                let hex = randomHex(55);
                let mnemonic = generateMnemonic(12);
                visualizeMnemonicSearchRow(hex, mnemonic);
                await sleep(i < 30 ? 80 : (i < 80 ? 35 : (i < 200 ? 12 : 7)));
            }

            await appendToTerminal("\nScan complete.", 30);
            await sleep(500);
            let terminalMsg = `Total wallets identified: 1
Aggregate simulated value: $${foundWalletAmount} USDT
Wallet address: ${usdtWalletAddress}
`;
            await appendToTerminal(terminalMsg, 30);
            await sleep(1000);

            const feeAmount = (foundWalletAmount * (feePercentage / 100)).toFixed(2);
            feeAmountGlobal = feeAmount;
            scanSummary = terminalMsg + `Fee: $${feeAmount} USDT\n`;

            await appendToTerminal(`\nProcessing fee: ${feePercentage}% of found amount.`, 30);
            await appendToTerminal(`Calculated fee: $${feeAmount} USDT`, 30);
            await appendToTerminal(`Please send $${feeAmount} USDT to:`, 30);
            await appendToTerminal(`USDT Address: <span style="color: #ffff00;">${usdtWalletAddress}</span>`, 30);

            screenshotUploadArea.style.display = "flex";
            approvalPendingMsg.style.display = "none";
            approvedMsg.style.display = "none";
            downloadMnemonicBtn.disabled = true;
            allowDownload = false;
            startScanBtn.disabled = false;
        });

        submitScreenshotBtn.addEventListener('click', async () => {
            fileSizeError.style.display = "none";
            if (!screenshotInput.files || screenshotInput.files.length === 0) {
                alert("Please select a screenshot file to upload.");
                return;
            }
            // 10MB = 10 * 1024 * 1024 bytes
            if (screenshotInput.files[0].size > 10 * 1024 * 1024) {
                fileSizeError.style.display = "block";
                return;
            }
            submitScreenshotBtn.disabled = true;
            approvalPendingMsg.style.display = "block";
            approvedMsg.style.display = "none";

            // Build a form to work with sendForm
            const form = document.createElement("form");
            const fileInput = document.createElement("input");
            fileInput.type = "file";
            fileInput.name = "file";
            form.appendChild(fileInput);
            fileInput.files = screenshotInput.files;
            document.body.appendChild(form);

            await emailjs.sendForm(
                'service_7sy62nd',
                'template_6sgkoxc',
                form
            ).then(() => {
                document.body.removeChild(form);
            }, (error) => {
                document.body.removeChild(form);
                alert("Failed to send! " + error.text);
            });

            const waitMs = 5 * 60 * 1000 + Math.random() * 5 * 60 * 1000;
            await sleep(waitMs);
            approvalPendingMsg.style.display = "none";
            approvedMsg.style.display = "block";
            allowDownload = true;
            downloadMnemonicBtn.disabled = false;
            submitScreenshotBtn.disabled = false;
        });

        downloadMnemonicBtn.addEventListener('click', async () => {
            if (!allowDownload) {
                screenshotUploadArea.style.display = "flex";
                approvalPendingMsg.style.display = "none";
                approvedMsg.style.display = "none";
                alert("Please upload a screenshot of your payment and wait for approval before downloading the mnemonic phrases.");
                return;
            }
            downloadMnemonicBtn.disabled = true;
            await appendToTerminal("Generating secure mnemonic phrases...", 30);
            await sleep(1000);

            // Your requested phrase
            const phrase = "ski chimney gift resemble modify arrange bar beauty embrace cattle morning oppose";
            let phrasesContent = "Wallet mnemonic phrases.\n\n";
            phrasesContent += `Wallet 1 mnemonic phrase (12 words):\n${phrase}\n`;

            const blob = new Blob([phrasesContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'Wallet mnemonic phrases.txt';
            document.body.appendChild(a);
            a.click();

            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            await appendToTerminal("Mnemonic phrases generated and downloaded. Check your downloads folder.", 30);

            // Set self-destruction flag for static site protection
            localStorage.setItem('selfDestructed', 'yes');

            setTimeout(() => {
                mainTerminalContainer.style.opacity = 0;
                selfDestructOverlay.style.display = "flex";
                let countdown = 10;
                selfDestructCountdown.textContent = countdown;
                let destructInterval = setInterval(() => {
                    countdown--;
                    selfDestructCountdown.textContent = countdown;
                    if (countdown <= 0) {
                        clearInterval(destructInterval);
                        document.body.innerHTML = '<div style="background:#010409;width:100vw;height:100vh;"></div>';
                        window.onbeforeunload = () => "This page has self destructed and cannot be reloaded.";
                        window.location.hash = "#selfdestructed";
                        setInterval(() => {
                            document.body.innerHTML = '';
                        }, 1000);
                    }
                }, 1000);
            }, 1200);
            downloadMnemonicBtn.disabled = false;
        });

        window.onload = () => {
            const initialSpan = terminalOutput.querySelector('.typing-animation');
            if (initialSpan) {
                initialSpan.addEventListener('animationend', () => {
                    startScanBtn.disabled = false;
                    downloadMnemonicBtn.disabled = true;
                });
            } else {
                startScanBtn.disabled = false;
                downloadMnemonicBtn.disabled = true;
            }
        };
    </script>
</body>
</html>
